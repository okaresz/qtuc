if device removed, high cpu usage?! -> QtSerialPort bug, or even lower (moserial also)

--- timestamping ------------------------------------------------------------------------------------

set @35d2 hwiname varName 0x3f5d20

the optional timestamp is a hex number after a "@" sign, meaning the microseconds since device startup (so the stamp is relative to device boot)
since qcProxy stores variable last update time with UNIX timestamp, it needs the device startup time to synchronize the two and calculate the UNIX stamp from the device stamp.
qcProxy will take the time of the first device command (ideally a device greeting), and store it as the base reference for the future device stamps.
If this first device command contains a timestamp, the value of that timestamp is taken into account when calculating the reference time, whoch in this case
is theoratically the actual device startup time (or the start of the device timekeeping to be exact)
If the device timestamp is omitted from the command, the time of arrival will be used.

Since logging and plotting is the task of a client, the client must first acquire the stateVariable to log. This can be with explicit get command or with subscription.
Either way, normally it is not guarantied that all update of the device variable will be cought by the client, but all registered updates will be stored with the correct time (not the time of arrival), thanks to the timestamps.
However, by using the proxy in passthrough mode, full synchronization without update loss is achievable.

---------------------------------------------------------------------------------------

error():
	use Q_FUNC or similar macro instead of the hardcoded function names
	would be nice to include __LINE__ and __FILE__, maybe with an error macro
	timestamping all errors and info

make a qcInfo() function or something to print state info to stdout (always printed, independent of verbopsity or debuglevel)
	-> add a verbosity level, level 1 (-v) will be debugLevelInfo, and so on...
	timestamp!

global optimization
	use compiler optimization
	volatile, inline, ...
	manual code optimization for speed, starting on the critical parts
	-> code profiling?...

don't subscribe if var is write-only (or sg like this...)

Figure out some sane Packet and command deletion plan...
	all packets and commands are deleted by sendPacket and send* functions
	incoming packets and commands are deleted after use: packets are when commands are detached from them, commands are at higher level...
	document this.

check and implement the device-safe string handling at receiving/sending commands
check QObject parents
check destructor chains, proper object deletions

implement connection lost detection

statevariable rawvval and val are not initialised upon creation, and the variable will be invalid, unable to get
->initVal node to apiXML (optional)

USE INIT FUNCTIONS
if multiple constructors exist, you will always forget to update one of them... (if some modifications needed in the common c'tor code)

doc todo-s

write a short how-to use for every class doc.

fix doxygen errors
check doc, write missing func/class doc
class references must include namespace.... QtuC::

check whole code for memleaks

"All the QObjects derived classes which will become child of any object in your program should be on heap. "

delete all member object instances, created with new in constructors.

validate deviceAPI.xml! : http://doc.qt.digia.com/4.7/xmlpatterns-schema.html

packet/commandClass chaos...

------------------
QtSerialPort building:

just build it.
for debug build, change QT.serialport.name to SerialPortd in src/serialport/serialport.pri
	this will be both the .so file name and the SONAME, which you can read with readelf -d <so file>
copy somewhere, where the linker can find it. both compile- and runtime.
